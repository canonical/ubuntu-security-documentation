#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright 2008-2016 Canonical, Ltd.
# Author: Kees Cook <kees@ubuntu.com>
# Copyright 2025 Canonical, Ltd.
# Author: Marek Such√°nek <marek.suchanek@canonical.com>
# License: GPLv3

import argparse
import json
import sys

from pydantic import BaseModel, Field, PositiveInt, ValidationError

NAME = 'dump-features'
DESCRIPTION = '''
This program generates a table with ReStructuredText markup that lists
Ubuntu security features and their status in various Ubuntu releases.
'''

def eprint(*args, **kwargs):
    """
    Print to stderr
    """
    print(*args, file=sys.stderr, **kwargs)

def args_from_cli() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
                    prog=NAME,
                    description=DESCRIPTION)
    
    parser.add_argument(
        '-H',
        '--historical',
        help="Display all releases, including EOL",
        action='store_true')
    parser.add_argument(
        '-o',
        '--output',
        help="Write the table to this file; otherwise, print to stdout",
        nargs='?',
        type=argparse.FileType('w'),
        default=sys.stdout)

    return parser.parse_args()

args = args_from_cli()

UNIMPLEMENTED = 0
AVAILABLE = 1
DEFAULT = 2
color = { "UNIMPLEMENTED": 'dddddd', "AVAILABLE": '98fd98', "DEFAULT": '00dd00' }

class Release(BaseModel):
    """
    This is an Ubuntu release as described in releases.json
    """
    code_name: str
    human_name: str
    is_eol: bool

def load_releases() -> list[Release]:
    """
    Load the releases list
    """
    with open("releases.json") as f:
        raw_releases = json.load(f)

    try:
        releases = [Release(**r) for r in raw_releases]
        return releases
    except ValidationError as e:
        eprint(e)
        sys.exit(1)

releases = load_releases()

class Implementation(BaseModel):
    """
    This is the status of the implementation of a security feature
    in a given Ubuntu release as listed in features.json
    """
    status: str
    state: str

    def default():
        """"
        The default state of an implementation is unimplemented
        """
        return Implementation(status="--", state="UNIMPLEMENTED")

class Feature(BaseModel):
    """
    This is a security feature as listed in features.json
    """
    name: str
    short: str
    # TODO: When we decide how to represent and structure the sections,
    # revisit these lines and make the checking stricter.
    section: bool = Field(default=False)
    matrix: dict[str, Implementation] = Field(default={})

def load_features() -> list[Feature]:
    """
    Load the features list
    """
    with open("features.json") as f:
        raw_features = json.load(f)
    
    try:
        features = [Feature(**f) for f in raw_features]
        return features
    except ValidationError as e:
        eprint(e)
        sys.exit(1)

features = load_features()

def table_row(cells: list) -> str:
    first_cell = True
    out = ""

    for cell in cells:
        if first_cell:
            out += f"   * - {cell}\n"
            first_cell = False
        else:
            out += f"     - {cell}\n"
    
    return out

# Explain the table format
args.output.write('''
Matrix
------

.. list-table:: Table format
   :header-rows: 1

   * - Text format
     - Meaning
   * - **Bold**
     - By default
   * - Regular
     - Available
   * - --
     - Unimplemented
''')

args.output.write('''
.. list-table:: Security features in releases
   :header-rows: 1

''')

# Report release name headers
if args.historical:
    header_releases = releases
else:
    header_releases = [r for r in releases if not r.is_eol]

release_names = [r.human_name.replace("Ubuntu ", "") for r in header_releases]

table_corner = "Feature"

header = table_row([table_corner, *release_names])

args.output.write(header)
args.output.write("\n")

def cell_with_markup(cell: Implementation) -> str:
    """
    Format the cell content as an RST string
    """
    # Default features add special markup, currently bold:
    if cell.state == "DEFAULT":
        return f"**{cell.status}**"
    else:
        return f"{cell.status}"

for feature in features:
    if feature.section:
        continue

    # The first cell in this row names the feature and links to its section
    cells = [f":ref:`{feature.short} <{feature.name}>`"]

    # Every feature starts as unimplemented until the first recorded change
    current_development = Implementation.default()

    for rel in releases:
        item = feature.matrix.get(rel.code_name)

        if item is not None:
            current_development = item

        if not args.historical and rel.is_eol:
            continue
        else:
            cell = cell_with_markup(current_development)
            cells.append(cell)
    
    args.output.write(table_row(cells))
    args.output.write('\n')

args.output.flush()
