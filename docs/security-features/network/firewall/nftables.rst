nftables
========

`nftables <https://www.nftables.org/projects/nftables/index.html>`_ is a
component in the Linux Netfilter subsystem that provides the most modern
framework for defining packet classification and filtering functionality. As
such, it is a successor to the ``iptables`` / ``ip6tables`` / ``arptables`` /
``ebtables`` kernel component and userspace utilities.

This documentation uses the term ``nftables`` when referring to the Linux kernel
component and ``nft`` when referring to userspace utility. Please note that the
Ubuntu package that provides the userspace utility is called ``nftables`` and
this documentation will refer to it as the ``nftables`` Ubuntu package.

Advantages
----------

There are several advantages to using ``nftables`` over the older alternatives:
  * The expressions forming the packet classification rules are compiled in
    userspace to bytecode and executed by the kernel using a purpose-built
    virtual machine; this allows for far more flexibility.
  * High-performance can be achieved through maps and concatenations: instead of
    linear rule processing (O(n)), constant time (O(1)) can be achieved.
  * The syntax used by the userspace nft utility is declarative, instead of the
    procedural format required for ``ip/ip6/arp/ebtables``, simplifying
    management of firewall configuration
  * Tables and chains are not predefined and the structure allows registering
    an arbitrary number of them: this facilitates the independent management of
    rules by multiple applications.
  * Packet forwarding can be accelerated by using the ``flowtables``
    functionality, which also integrates with selected hardware.
  * Common rules for IPv4 and IPv6 can be defined, unlike with the older
    ``iptables`` and ``ip6tables``.
  * Tracing of the rules' evaluation for specific packets can be easily enabled.

Netfilter integration
---------------------

The ``nftables`` component is integrated into the existing Netfilter subsystem
and uses the same hooks, stateful processing for connection tracking or NAT, and
functionality for userspace packet queueing and processing.

Packet flow
~~~~~~~~~~~

A packet starts being handled by Netfilter through one of three options:
  * it is received by a network interface driver (whether for physical NIC or a
    virtual one);
  * it is generated by an application process on the system;
  * it is generated by the kernel.

The Netfilter processing will go through multiple decision points, potentially
modifying the packet, such as:
  * fragment reassembly;
  * connection tracking;
  * routing decisions;
  * source and destination NAT (including port translation).

Netfilter provides hooks that allow Netfilter components to process a packet at
various stages. These are used by both ``nftables`` and ``iptables`` /
``ip6tables`` / ``ebtables`` / ``arptables`` to execute user-defined rules. In
particular, the names of the predefined chains in the legacy ``iptables`` /
``ip6tables`` / ``ebtables`` / ``arptables`` are derived from names of the
Netfilter hooks:
    * ``ingress`` (only available for ``nftables``)
    * ``prerouting`` (for bridge and IP)
    * ``input`` (for ARP, bridge and IP)
    * ``forward`` (for bridge and IP)
    * ``postrouting`` (for bridge and IP)
    * ``output`` (for ARP, bridge and IP)
    * ``egress`` (only available for ``nftables``)

Packets will not traverse all hook points: this depends on the some of the
decisions made during the processing. This is represented graphically in the
diagram on the `Netfilter hooks nftables wiki page
<https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks>`_.

It should be noted that some of the standard Netfilter processing is performed
at some of the hook points (fragment reassembly, connection tracking lookup,
NAT), while others are in-between hook points (routing decision). At each hook
point, the order of operations is defined by a priority. For example, these
are some of the standard operations executed at the IP layer ``prerouting`` hook:

.. csv-table::
    :header: Netfilter priority value, Operation
    :widths: auto

    -400, fragment reassembly
    -200, connection tracking lookup and association
    -100, destination NAT

If you register rules to be executed at priority value lower than ``-400`` (e.g.
``-500``), these will be executed before IP datagram fragments are reassembled.
As such the rules may see IP datagram fragments for which the transport header
may not be available, because they are not the first fragment. On the other
hand, rules registered at priority value higher than ``-400`` (e.g. ``-300``)
would not be able to make decisions based on fragmentation information (the
packet would look as if the entire IP datagram was received).

The priority values themselves do not hold any intrinsic meaning, other than the
fact that some standard operations are executed at well-known priority values.
For example, in absence of other context, registering rules at priority ``1000``
is no different from using priority ``1500``. The `nftables documentation
<https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks#Priority_within_hook>`_
lists the well-known priority values.


Compatibility
-------------

In general, all the rules that can be defined using ``iptables``,
``ip6tables``, ``arptables`` and ``ebtables`` can also be defined using
``nftables``, but not the other way around. It is strongly recommended that you
only use one of two appraoches to managing firewall rules.

Starting with Ubuntu 16.04 Xenial Xerus, the ``iptables`` package has provided
versions of the ``iptables``, ``ip6tables``, ``arptables`` and ``ebtables``
tools that work with ``nftables`` API and provide a compatible interface to the
legacy implementation. The ``nftables`` backend has been the default since
Ubuntu 20.10 Groovy Gorilla. These are managed through the alternatives system
and the current configuration can be displayed with the following commands:

.. code-block:: console

    $ update-alternatives --display iptables
    $ update-alternatives --display ip6tables
    $ update-alternatives --display arptables
    $ update-alternatives --display ebtables


``ufw`` works by invoking the legacy ``iptables`` and ``ip6tables`` utilities.
As such, it should not be used concurrently with native ``nftables`` firewall
rules.

Usage
-----

AF_NETLINK, systemd unit, file format, tracing.

Structure
---------

Rule composition
~~~~~~~~~~~~~~~~

Sets
~~~~

Maps
~~~~

Stateful objects
~~~~~~~~~~~~~~~~

Flowtables
~~~~~~~~~~
