Snap Confinement
================

A snap’s confinement level controls the degree of isolation it has from the user’s system. Application developers or packagers can adjust the confinement level to specify in broad terms how much access to system resources an application needs, either for normal use or during development.

There are multiple levels of snap confinement for snaps:

* Strict
* Classic 
* Devmode

See `Snap Confinement <https://snapcraft.io/docs/snap-confinement#p-29237-confinement-levels>`_ for more details.

In order to achieve confinement, snaps utilise multiple Linux isolation and confinement mechanisms. These are:

* AppArmor
* Seccomp
* Device cgroups
* Traditional permissions and Mount namespaces

See `Confinement and isolation mechanisms <https://snapcraft.io/docs/security-policies#p-2741-confinement-and-isolation-mechanisms>`_ for more details.

Confinement Types 
#################

Strict
------

Strict confinement is declared in a snapcraft.yaml through ``confinement: strict``.
This level of confinement utilises all of the confinement mechanisms listed above to ensure the snap executables and data are sandboxed, with limited access.

Interfaces
^^^^^^^^^^

In order to gain access to certain resources provided by other snaps or on the host system, the snap ecosystem introduces the concept of interfaces.
Interfaces are composed by:

* slots: used by snaps or the system (implicit slot) to expose resources
* plugs: used by snaps to consume access resources exposed by a slot

See `Interfaces <https://snapcraft.io/docs/interfaces>`_ for more details.

Interface Connections
"""""""""""""""""""""

By connecting a plug with a slot, the snap that defines the plug will have access to the resource provided by the slot.
Interface connections can occur manually or automatically and this is dependent on the function of the interface.
Manual connections require users to use the ``snap connect`` command to achieve this connection.
Whereas auto-connections are handled by snapd whenever a snap is installed or refreshed.

See `Interface auto-connection mechanism <https://snapcraft.io/docs/auto-connection-mechanism>`_ for more details.

Interface Privileges
""""""""""""""""""""

Some interfaces enable snaps to control or access sensitive or privileged areas of a system.
For example, the ``snapd-control`` interface enables a snap to communicate with snapd to allow snap removal, installation, etc.
Interfaces like this are known as ``super-privileged`` interfaces and extra security measures are taken to restrict or permit access.
These require approval from ``@reviewers`` (store review team) on https://forum.snapcraft.io/ and require the default store-set policy for that interface to be overridden.

See `Super-privileged interfaces <https://snapcraft.io/docs/super-privileged-interfaces>`_ for more details.

Classic
-------

Classic confinement is declared in a snapcraft.yaml through ``confinement: classic``.
These snaps have no confinement and allows access to the system’s resources in much the same way traditional packages do.
Because of this, manual review is required to publish this type of snap.
Since these types of snaps are not isolated from the host, much like any other 3rd party package, it may run into binary incompatibilities at runtime.
It is important to note that ``classic`` snaps **are not supported** run on Ubuntu core systems.

Devmode
-------

Devmode confinement is declared in a snapcraft.yaml through ``confinement: devmode``.
This level of confinement is used during the development of snaps. 
Devmode runs snaps similarly to strictly confined snaps, however, instead of limiting access to the host system resources, it produces a debug output to enable developers to identify what access or interfaces may be needed for the snap to run as strictly confined.
To facilitate debugging, snaps with ``strict`` confinement can also be installed with the ``--devmode`` argument (e.g ``snap install <snap_name> --devmode``).

Confinement Mechanisms
######################

AppArmor
--------

AppArmor profiles are generated by snapd for each app (a particular way of invoking an executable) and service (daemon managed by snapd) defined in a snap package.
Declaring interfaces in the snap allows the default AppArmor profile to be extended.
`This default profile <https://github.com/canonical/snapd/blob/8105ec1a7395c7a0c0126a4fff66a063d326c3f1/interfaces/apparmor/template.go#L63>`_ defines a common set of rules that are applied to all snaps by default.
For example, when a snap plugs the camera interface, `this profile <https://github.com/canonical/snapd/blob/8105ec1a7395c7a0c0126a4fff66a063d326c3f1/interfaces/builtin/camera.go#L32>`_ is added to extend the default policy.
Whenever an interface is connected or disconnected from a snap, the Apparmor profiles are regenerated for that snap.

See :doc:`apparmor` for more details.

Seccomp
-------

Similarly to how AppArmor is used for snaps, Seccomp filters are also generated by snapd for each app in a snap.
These allow for processes inside the snap to have syscall filtering. Again, these can be extended through the use of snap interfaces.
Whenever an interface is connected or disconnected from a snap, the Seccomp filters are regenerated for that snap.

See :any:`seccomp-filtering` for more details.

Device cgroups
--------------

For snaps using bases ``core24`` and later, cgroups are only used by snapd to manage access to device files through the `device controller <https://docs.kernel.org/admin-guide/cgroup-v2.html#device-controller>`_ mechanism.
The device controller is implemented as a BPF program of type ``BPF_PROG_TYPE_CGROUP_DEVICE`` and is attached to the cgroup.
Prior to ``core24``, access to device files is managed using `device filtering <https://docs.kernel.org/admin-guide/cgroup-v1/devices.html>`_.
Device filtering is only added when udev tags any devices for that snap.
This is determined by the interfaces used by a snap (e.g `custom-device <https://snapcraft.io/docs/custom-device-interface>`_).
Udev rules are generated in ``/etc/udev/rules.d/70-snap...`` and tags are added to the devices (hardware) associated with the use of this interface.
If a snap has tagged devices, a cgroup is created in ``/sys/fs/cgroup/devices/`` to allow access to these devices and other common devices (e.g `/dev/null`).
Whenever an interface is connected or disconnected from a snap, the device cgroups are regenerated for that snap.

See :doc:`cgroups` for more details.

Traditional permissions and Mount namespaces
--------------------------------------

Processes inside the snap that try to access resources are restricted by the typical file permissions on the system (owner, group, file ACLs, etc).
All the processes from the same snap exist in the same mount namespace to ensure isolation from separate snaps in their own mount namespaces.

See `Security Overview <https://snapcraft.io/docs/security-policies#p-2741-security-overview>`_ for more details.